---
layout: post
title: Early termination with social signals
---
<h2>Early termination</h2>
<p>
  Early termination is a common technique used in search engine development to reduce query latency on large indexes. The idea is simple, if we were to order the posting-list in decreasing significances or relevance order measured by some sort of query-independent static rank, e.g. Google's PageRank on a webpage. Then, as we process the posting list, we can terminate posting traversal when we have collected enough hits before finish walking the entire list.
</p>
<p>
  An important observation is that with early termination, the query latency does not grow linearly as index size grows. To return only the top N hits is very consistent with a search engine's access pattern.
</p>
<p>
	The following simple code snippet illustrates how this works:
<pre class="prettyprint">
int numHitsRequested = ...
int numHitsCollected = ...

int docid = ...
...
public int nextDoc(){
  if (docid != NO_MORE_DOCS &amp;&amp; numHitsCollected &lt; numHitsRequested){
    return (docid = nextHit());	
  }
  else{
	return (docid = NO_MORE_DOCS);
  }
}
</pre>
</p>
<h2>User/People search</h2>
<p>
	In the world of social search, one common use-case is to search for people. In such a context, a person is represented as a document and add into a user index. There are many signals to produce static ranks for a given user, i.e.: page-rank like score from the social graph, activity information etc. As we build the index, we can build the posting list in descending order of the static rank, and apply early termination at query-time.
</p>
<h3>Social Signals</h3>
<p>
	Social information are strong signals when we search for people, i.e. we want to give importance to people in our immediate and extended networks. Unfortunately, this cannot be incorporated in to the static rank because it is query-dependent.
</p>
<p>
	So it is desirable to augment the early termination logic above for the following condition:
</p>
<p>
	We terminate iterating the posing list if:
</p>
<p class="lead">
	Number of users collected reached number of hits requested AND all users in the social networks have been examined.
</p>
<h3>User to doc mapping</h3>
<p>
	In a <a href="/2012/09/24/lucene-uid-docid-mapping.html">previous post</a>, we discussed a way to store UIDs that we can later construct an array indexed by docids for fast docid-Uid mapping. From this lookup array, we then construct a fast hash to map from Uids back to docids. So given a set of UIDs, we can map them back into the docid-space. See <a href="#">this class</a> in <a href="#">Zoie</a> which implements such a hash. I timed on my laptop, a map takes approximately 120 nanoseconds. So for mapping 10,000 UIDs, it would take slightly more than 1ms.
</p>
<h3>Building a DocIdSetIterator</h3>
	